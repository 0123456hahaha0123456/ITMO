Схема умножения -----------------------------------------------------------------------------

module mult(
	input clk_i,
	input rst_i,
	input [7:0] a_bi,
	input [7:0] b_bi,
	input start_i,
	output busy_o,
	output reg [15:0] y_bo
);

localparam IDLE = 1'b0;
localparam WORK = 1'b1;

reg [2:0] ctr;
wire [2:0] ctr_next, end_step;
wire [7:0] part_sum;
wire [15:0] shifted_p;
reg [7:0] a, b;
reg [15:0] part_res;
reg state;

assign part_sum = a & {8{b[ctr]}};
assign shifted_p = part_sum << ctr;
assign ctr_next = ctr + 1;
assign end_step = (ctr == 3'h7);
assign busy_o = state;

always@(posedge clk_i)
	if(rst_i) begin
		ctr <= 0;
		part_res <= 0;
		y_bo <= 0;
		state <= IDLE;
	end else begin
		case(state)
			IDLE:
				if(start_i) begin
					state <= WORK;
					a <= a_bi;
					b <= b_bi;
					ctr <= 0;
					part_res <= 0;
				end
			WORK: begin
				if(end_step) begin
					state <= IDLE;
					y_bo <= part_res;
				end
				part_res = part_res + shifted_p;
				ctr <= ctr + 1;
			end
		endcase
	end
endmodule 


Схема вычисления кубического корня -----------------------------------------------------------------------------
module mult(
	input clk_i,
	input rst_i,
	input [7:0] a_bi,
	input [7:0] b_bi,
	input start_i,
	output busy_o,
	output reg [15:0] y_bo
);

localparam IDLE = 1'b0;
localparam WORK = 1'b1;

reg [2:0] ctr;
wire [2:0] ctr_next, end_step;
wire [7:0] part_sum;
wire [15:0] shifted_p;
reg [7:0] a, b;
reg [15:0] part_res;
reg state;

assign part_sum = a & {8{b[ctr]}};
assign shifted_p = part_sum << ctr;
assign ctr_next = ctr + 1;
assign end_step = (ctr == 3'h7);
assign busy_o = state;

always@(posedge clk_i)
	if(rst_i) begin
		ctr <= 0;
		part_res <= 0;
		y_bo <= 0;
		state <= IDLE;
	end else begin
		case(state)
			IDLE:
				if(start_i) begin
					state <= WORK;
					a <= a_bi;
					b <= b_bi;
					ctr <= 0;
					part_res <= 0;
				end
			WORK: begin
				if(end_step) begin
					state <= IDLE;
					y_bo <= part_res;
				end
				part_res = part_res + shifted_p;
				ctr <= ctr + 1;
			end
		endcase
	end
endmodule 



Схема тестирования -----------------------------------------------------------------------------------
module sqrt3_tb;
reg clk_c_i;
reg rst_c_i;
reg start_c_i;
reg [7:0] x_i;
wire res_o;
wire [7:0] s_o;

sqrt3 dut(.clk_c_i(clk_c_i),
		  .rst_c_i(rst_c_i),
		  .start_c_i(start_c_i),
		  .x_i(x_i),
		  .res_o(res_o),
		  .y_o(s_o)
);

integer i, xx, bb, kol_ok, kol_error;

initial
	begin
		$display("HEY");
		// $monitor("c = %b, res = %d, r = %b, time = %0d", clk_c_i, s_o, res_o, $time);
		kol_ok = 0;
		kol_error = 0;
		for(xx = 1; xx <= 255; xx = xx + 1) begin
            clk_c_i = 0; rst_c_i = 1; start_c_i=1; x_i = xx;
            #10 clk_c_i = 1; rst_c_i = 1;
            #10 clk_c_i = 0; rst_c_i = 0;
            for (i = 0; i < 15; i = i + 1) begin
                #100 clk_c_i = 1;
                #100 clk_c_i = 0;
            end
            
            bb = 0;
            while(bb * bb * bb <= xx) begin
                bb = bb + 1;
            end
            bb = bb - 1;
            
            if(bb != s_o) begin 
                kol_ok = kol_ok + 1; 
                $display("~~~ Error xx = %b, res = %d, r = %b, time = %0d", xx, s_o, res_o, $time);
            end 
            else begin
                kol_error = kol_error + 1;
                $display("~~~ OK xx = %b, res = %d, r = %b, time = %0d", xx, s_o, res_o, $time);
            end
	   end
	   $display(" ~~~ kol_OK = %d, kol_Error = %d ", kol_ok, kol_error);
	   #10 $stop;
	end
endmodule 



















